var fs   = require('fs');
var mime = require('mime');
var mimelib = require("mimelib");

function escapeHtml(text) {
  return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
}

/*
 * @constructor
 */
function MsOfficeWordHTMLWriter(options) {
    var options = options || {};

    this.head         = options.head       || "";
    this.hf_head      = options.hf_head    || "";
    this.title        = options.title      || "Document generated by MsOfficeWordHTMLWriter";
    this.sections     = options.sections   || [ {} ];
    this.MIME_parts   = options.MIME_parts || [];
    this.WordDocument = options.WordDocument;
}

MsOfficeWordHTMLWriter.prototype = {
    create_section: function(params) {
        // if first automatic section is empty, delete it
        if ( this.sections.length == 1 && !this.sections[0].content ) {
            this.sections = [];
        }

        // add the new section
        this.sections.push(params);

        return this;
    },

    write: function() {
        var section = this.sections[this.sections.length - 1];
        section.content = (section.content || '') + Array.prototype.join.call(arguments, "");
        return this;
    },

    save_as: function(filename, callback) {
        var self = this;
        // default ext is doc
        if ( ! /\.\w{1,5}$/.test(filename)  ) {
            filename += ".doc";
        }

        fs.writeFile( filename, this.content(), function(err) {
            if (err) throw err;
            if (callback) callback(self);
        });

        return this;
    },

    attach: function(filename, filepath, callback) {
        var self = this;

        fs.readFile(filepath, function (err, data) {
            if (err) throw err;
            self.MIME_parts.push(["files/" + filename, data]);
            if (callback) callback(self);
        });

        return this;
    },

    page_break: function(pbreak) {
        return "<br clear='all' style='page-break-before:" + (pbreak || 'always') + "'>\n";
    },

    tab: function(n_tabs) {
        return "<span style='mso-tab-count:" + (n_tabs || 1) + "'></span>";
    },

    field: function(fieldname, args, content) {
        var args    = escapeHtml(args || "");
        var content = escapeHtml(content || "");
        var field;

        // when args : long form of field encoding
        if (args) {
            var space = "<span style='mso-spacerun:yes'> </span>";
            field = "<span style='mso-element:field-begin'></span>"
                    + space + fieldname + space + args
                    + "<span style='mso-element:field-separator'></span>"
                    + content
                    + "<span style='mso-element:field-end'></span>";
        } else {
            field = "<span style='mso-field-code:\"" + fieldname + "\"'>" + content + "</span>";
        }

        return field;
    },

    quote: function(text) {
        return this.field( 'QUOTE', text.replace(/"/, '\\&quot;'), text );
    },

    content: function() {
        // separator for parts in MIME document
        var boundary = "__NEXT_PART__";

        // MIME multipart header
        var mimeStr = "MIME-Version: 1.0\n"
                + "Content-Type: multipart/related; boundary=\"" + boundary + "\"\n\n"
                + "MIME document generated by MsOfficeWordHTMLWriter\n\n";

        // generate each part (main document must be first)
        var MIME_parts = this._MIME_parts();
        var filelist   = this._filelist(MIME_parts);
        var main       = this._main();
        var parts = [main].concat(MIME_parts).concat([filelist]);

        parts.forEach(function(pair) {
            var filename = pair[0];
            var content  = pair[1];
            var mimeType = mime.lookup(filename);

            var encoding, encoded;
            if ( /^text|xml$/.test( mimeType ) ) {
                encoding = 'quoted-printable';
                encoded  = mimelib.encodeQuotedPrintable( content.replace(/\r\n/, "\n") );
            } else {
                encoding = 'base64';
                encoded  = mimelib.encodeBase64( content );
            }
            mimeStr += "--" + boundary + "\n"
                 + "Content-Location: file:///C:/foo/" + filename + "\n"
                 + "Content-Transfer-Encoding: " + encoding + "\n"
                 + "Content-Type: " + mimeType + "\n\n"
                 + encoded
                 + "\n";
        });
        
        // close last MIME part
        mimeStr += "--" + boundary + "--\n";
        
        return mimeStr;
    },

    _main: function() {
        var body  = ""; // body : concatenate content from all sections

        this.sections.forEach(function(section, index) {
            if ( index > 0 ) { // section break
                var breakt = section.new_page === true // type of break
                    ? 'always' 
                    : section.new_page || 'auto';

                // insert into body
                var style = "page-break-before:" + breakt + ";mso-break-type:section-break";
                body += "<br clear=all style='" + style + "'>\n";
            }

            body += "<div class=\"Section" + index + "\">\n" + (section.content || '') + "\n</div>\n";
        });
        
        var html = //assemble head and body into a full document
            "<html xmlns:v=\"urn:schemas-microsoft-com:vml\"\n"
          + "      xmlns:o=\"urn:schemas-microsoft-com:office:office\"\n"
          + "      xmlns:w=\"urn:schemas-microsoft-com:office:word\"\n"
          + "      xmlns:m=\"http://schemas.microsoft.com/office/2004/12/omml\"\n"
          + "      xmlns=\"http://www.w3.org/TR/REC-html40\">\n"
          + this._head()
          + "<body>\n" + body + "</body>\n"
          + "</html>\n";

        return ["main.htm", html];
    },

    _head: function() {
        var head = "<head>\n" // HTML head : link to filelist, title, view format and styles
          + "<link rel=File-List href=\"files/filelist.xml\">\n"
          + "<title>" + this.title + "</title>\n"
          + this._xml_WordDocument()
          + "<style>\n" + this._section_styles() + "</style>\n"
          + this.head
          + "</head>\n";
        
        return head;
    },

    _xml_WordDocument: function() {
        if ( ! this.WordDocument ) return "";

        return "<xml><w:WordDocument>\n"
            + this._w_xml( this.WordDocument )
            + "</w:WordDocument></xml>\n";
    },

    _w_xml: function(node) {
        var xml = '';

        for (var key in node) {
            if ( node.hasOwnProperty(key) ) {
                var val = node[key];
                xml += val 
                    ? "<w:" + key + ">"
                      + ( typeof(val) === "string" || typeof(val) === "number" ? val : arguments.callee( val ) )
                      + "</w:" + key + ">\n"
                    : "<w:" + key + " />\n"; // element without data
            }
        }

        return xml;
    },

    _section_styles: function() {
        var styles = "";

        this.sections.forEach(function(section, index) {
            var properties = "";
            // page properties (size and margin)
            ['size', 'margin'].forEach(function(prop) {
                if ( !section.page || !section.page[prop] ) return;
                var val = section.page[prop];
                properties += "  " + prop + ":" + val + ";\n";
            });

            // headers and footers 
            ['header_margin', 'footer_margin'].forEach(function(prop) {
                if ( !section.page || !section.page[prop] ) return;
                var val = section.page[prop];
                prop = prop.replace('_', '-');
                properties += "  mso-" + prop + ":" + val + ";\n";
            });

            var has_first_page;

            ['header', 'footer', 'first_header', 'first_footer'].forEach(function(hf) {
                if ( ! section[hf] ) return;
                has_first_page = /^first/.test(hf);
                var prop = hf.replace('_', '-');

                properties += "  mso-" + prop + ":url(\"files/header_footer.htm\") " + hf + index + ";\n";
            });

            if ( has_first_page ) {
                properties += "  mso-title-page:yes;\n";
            }

            // style definitions for this section
            styles += "@page Section" + index + " {\n" + properties + "}\n"
                   + "div.Section" + index + " {page:Section" + index + "}\n";
        });

        return styles;
    },

    _MIME_parts: function() {
        var parts = this.MIME_parts.slice(0) // attachments supplied by user

        // additional attachment : computed file with headers and footers
        var hf_content = this._header_footer();
        if ( hf_content ) {
            parts.push(["files/header_footer.htm", hf_content]);
        }

        return parts;
    },

    _header_footer: function() {
        // create a div for each header/footer in each section
        var hf_divs = "";

        this.sections.forEach(function(section, index) {
            ['header', 'footer', 'first_header', 'first_footer'].forEach(function(hf) {
                if ( !section[hf] ) return;
                var style = hf.replace('first_', '');

                hf_divs += "<div style='mso-element:" + style + "' id='" + hf + index + "'>\n"
                        + section[hf] + "\n"
                        + "</div>\n";
            });
        });

        // if at least one such div, need to create an attached file
        var header_footer = !hf_divs ? "" :
                  "<html>\n"
                + "<head>\n"
                + "<link id=Main-File rel=Main-File href=\"../main.htm\">\n"
                + this.hf_head
                + "</head>\n"
                + "<body>\n"
                + hf_divs
                + "</body>\n"
                + "</html>\n";
     
        return header_footer;
    },

    _filelist: function(parts) {
        // xml header
        var xml = "<xml xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n"
                + " <o:MainFile HRef=\"../main.htm\"/>\n";

        // refer to each attached file
        parts.forEach(function(part) {
            xml += " <o:File HRef=\"" + part[0] + "\"/>\n";
        });

        // the filelist is itself an attached file
        xml += " <o:File HRef=\"filelist.xml\"/>\n"
            + "</xml>\n";
         
        return ["files/filelist.xml", xml];
    }
};

module.exports = MsOfficeWordHTMLWriter;